<?xml version="1.0" encoding="utf-8"?>
<search> 
  
    
    <entry>
      <title><![CDATA[Java多线程Thread,Runnable, Callable<>和线程池(一)]]></title>
      <url>/2017/05/24/Java-hread-pool-001/</url>
      <content type="html"><![CDATA[<p>这一篇主要关注于我们自己实现和管理多线程，后面会介绍使用线程池实现多线程。<br>Java里面实现多线程有三种方式,继承 Thead类，或者实现Runnable和Callable&lt;&gt;接口。下面详细介绍一下这三种实现方式。</p>
<p>#1. Thread实现多线程<br>使用Thread实现，我们只需要继承Thread类，重写(overwirte)run方法。<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div><div class="line">23</div><div class="line">24</div><div class="line">25</div><div class="line">26</div><div class="line">27</div><div class="line">28</div></pre></td><td class="code"><pre><div class="line">class ThreadDemo extends Thread &#123;</div><div class="line">	private String threadFlag;</div><div class="line">	private long sleepTime = 100;</div><div class="line"></div><div class="line">	public ThreadDemo(String threadFlag) &#123;</div><div class="line">		System.out.println(&quot;Construct &quot; + threadFlag);</div><div class="line">		this.threadFlag = threadFlag;</div><div class="line">	&#125;</div><div class="line"></div><div class="line">	public ThreadDemo(String threadFlag, long sleepTime) &#123;</div><div class="line">		System.out.println(&quot;Construct &quot; + threadFlag);</div><div class="line">		this.threadFlag = threadFlag;</div><div class="line">		this.sleepTime = sleepTime;</div><div class="line">	&#125;</div><div class="line">	//重写run方法</div><div class="line">	public void run() &#123;</div><div class="line">		System.out.println(&quot;Running before: &quot; + this.threadFlag);</div><div class="line">		try &#123;</div><div class="line">			for (int i = 0; i &lt; 6; i++) &#123;</div><div class="line">				System.out.println(this.threadFlag + i);</div><div class="line">				Thread.sleep(this.sleepTime);</div><div class="line">			&#125;</div><div class="line">		&#125; catch (InterruptedException e) &#123;</div><div class="line">			e.printStackTrace();</div><div class="line">		&#125;</div><div class="line">		System.out.println(&quot;Running after:&quot; + this.threadFlag);</div><div class="line">	&#125;</div><div class="line">&#125;</div></pre></td></tr></table></figure></p>
<p>ThreadDemo类继承自Thread类,重写了Thread类的run()方法。当ThreadDemo调用start()方法的时候，run()方法会被调用。<br>下面是测试方法：<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div></pre></td><td class="code"><pre><div class="line">public class ConcurrentThread &#123;</div><div class="line"></div><div class="line">	public static void main(String[] args) throws InterruptedException, ExecutionException &#123;</div><div class="line"></div><div class="line">		long start = System.currentTimeMillis();</div><div class="line">		Thread tA = new ThreadDemo(&quot;Thread-A&quot;);</div><div class="line">		tA.start();</div><div class="line"></div><div class="line">		Thread tB = new ThreadDemo(&quot;Thread-B&quot;);</div><div class="line">		tB.start();</div><div class="line">		long end = System.currentTimeMillis();</div><div class="line">		System.out.println(&quot;During time: &quot; + (end - start));</div><div class="line"></div><div class="line">	&#125;</div><div class="line">&#125;</div></pre></td></tr></table></figure></p>
<p>测试方法里面创建了两个线程tA,tB，下面是执行的结果，可以看到tA和tB是没有先后顺序的，是两个独立的线程。<strong>“During Time:2”</strong>是主线程里面的语句，但是它在tA和tB没有执行完成的时候，已经开始执行。<br>说明这两个线程并没有阻塞主线程。<br><img src="http://img.blog.csdn.net/20170213084550303?watermark/2/text/aHR0cDovL2Jsb2cuY3Nkbi5uZXQvcWlzaWJhamll/font/5a6L5L2T/fontsize/400/fill/I0JBQkFCMA==/dissolve/70/gravity/SouthEast" alt="测试结果"></p>
<p>#2. Runnable实现多线程<br>另外一种实现多线程的方法是implement Runnable接口<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div><div class="line">23</div><div class="line">24</div><div class="line">25</div><div class="line">26</div><div class="line">27</div><div class="line">28</div><div class="line">29</div><div class="line">30</div><div class="line">31</div></pre></td><td class="code"><pre><div class="line">class RunnableImpl implements Runnable &#123;</div><div class="line"></div><div class="line">	private String threadFlag;</div><div class="line">	private long sleepTime = 100;</div><div class="line"></div><div class="line">	public RunnableImpl(String threadFlag) &#123;</div><div class="line">		System.out.println(&quot;Construct &quot; + threadFlag);</div><div class="line">		this.threadFlag = threadFlag;</div><div class="line">	&#125;</div><div class="line"></div><div class="line">	public RunnableImpl(String threadFlag, long sleepTime) &#123;</div><div class="line">		System.out.println(&quot;Construct &quot; + threadFlag);</div><div class="line">		this.threadFlag = threadFlag;</div><div class="line">		this.sleepTime = sleepTime;</div><div class="line">	&#125;</div><div class="line"></div><div class="line">	@Override</div><div class="line">	public void run() &#123;</div><div class="line">		System.out.println(&quot;Running before: &quot; + this.threadFlag);</div><div class="line">		try &#123;</div><div class="line">			for (int i = 0; i &lt; 6; i++) &#123;</div><div class="line">				System.out.println(this.threadFlag + i);</div><div class="line">				Thread.sleep(this.sleepTime);</div><div class="line">			&#125;</div><div class="line">		&#125; catch (InterruptedException e) &#123;</div><div class="line">			e.printStackTrace();</div><div class="line">		&#125;</div><div class="line">		System.out.println(&quot;Running after:&quot; + this.threadFlag);</div><div class="line">	&#125;</div><div class="line"></div><div class="line">&#125;</div></pre></td></tr></table></figure></p>
<p>RunnableImpl类实现了Runnable接口，实现了run()方法，是用start的方法去启动改线程。下面是测试方法和结果：<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div></pre></td><td class="code"><pre><div class="line">public class ConcurrentThread &#123;</div><div class="line"></div><div class="line">	public static void main(String[] args) throws InterruptedException, ExecutionException &#123;</div><div class="line"></div><div class="line">		long start = System.currentTimeMillis();</div><div class="line">		Thread tA = new Thread(new RunnableImpl(&quot;Thread-A&quot;));</div><div class="line">		tA.start();</div><div class="line"></div><div class="line">		Thread tB = new Thread(new RunnableImpl(&quot;Thread-B&quot;, 400));</div><div class="line">		tB.start();</div><div class="line">		long end = System.currentTimeMillis();</div><div class="line">		System.out.println(&quot;During time: &quot; + (end - start));</div><div class="line">	&#125;</div><div class="line">&#125;</div></pre></td></tr></table></figure></p>
<p><img src="http://img.blog.csdn.net/20170213101915884?watermark/2/text/aHR0cDovL2Jsb2cuY3Nkbi5uZXQvcWlzaWJhamll/font/5a6L5L2T/fontsize/400/fill/I0JBQkFCMA==/dissolve/70/gravity/SouthEast" alt="这里写图片描述"></p>
<p>使用RunnableImpl和Thread去创建两个线程tA和tB，从结果中看到tA和tB也是并发执行的，他们是随机的获取CPU的执行时间。<strong>“During time:4”</strong>在两个线程没有执行完成的时候已经输出了。说明这两个线程也没有阻塞主线程。</p>
<p>#3. Callable&lt;&gt;实现多线程<br>观察Thread和Runnable实现的线程，你会发现这两种实现，你是无法知道线程的执行状态的，例如：线程是否执行完成了，线程有没有被cancel等等。如果你需要基于线程的状态做些事情，就需要很多而外的工作。为了解决这些问题，Callable&lt;&gt;就应运而生了，它和FutureTask结合可以很好的解决这个问题。FutureTask一般有两个用途。<br>1.获取异步的结果和取消任务。</p>
<ol>
<li>高并发的情况下确保任务只会执行一次。<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div><div class="line">23</div><div class="line">24</div><div class="line">25</div><div class="line">26</div><div class="line">27</div><div class="line">28</div><div class="line">29</div></pre></td><td class="code"><pre><div class="line">import java.util.concurrent.Callable;</div><div class="line">import java.util.concurrent.ExecutionException;</div><div class="line">import java.util.concurrent.FutureTask;</div><div class="line"></div><div class="line">class CallableDemo implements Callable&lt;String&gt; &#123;</div><div class="line"></div><div class="line">	private String threadFlag;</div><div class="line">	private long sleepTime = 400;</div><div class="line"></div><div class="line">	public CallableDemo(String threadFlag) &#123;</div><div class="line">		System.out.println(&quot;Construct &quot; + threadFlag);</div><div class="line">		this.threadFlag = threadFlag;</div><div class="line">	&#125;</div><div class="line"></div><div class="line">	public CallableDemo(String threadFlag, long sleepTime) &#123;</div><div class="line">		System.out.println(&quot;Construct &quot; + threadFlag);</div><div class="line">		this.threadFlag = threadFlag;</div><div class="line">		this.sleepTime = sleepTime;</div><div class="line">	&#125;</div><div class="line"></div><div class="line">	@Override</div><div class="line">	public String call() throws Exception &#123;</div><div class="line">		System.out.println(&quot;Running before: &quot; + this.threadFlag);</div><div class="line">		Thread.sleep(this.sleepTime);</div><div class="line">		System.out.println(&quot;Running after:&quot; + this.threadFlag);</div><div class="line">		return this.threadFlag + &quot; success in this time&quot;;</div><div class="line">	&#125;</div><div class="line"></div><div class="line">&#125;</div></pre></td></tr></table></figure>
</li>
</ol>
<p>这里CallableImpl实现了Callable接口，实现了里面的call()方法，这个接口是泛型化的接口，接口的类型就是call()方法的返回值类型。下面是测试代码：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div></pre></td><td class="code"><pre><div class="line">public class ConcurrentThread &#123;</div><div class="line"></div><div class="line">	public static void main(String[] args) throws InterruptedException, ExecutionException &#123;</div><div class="line"></div><div class="line">		long start = System.currentTimeMillis();</div><div class="line">		FutureTask&lt;String&gt; futureA = new FutureTask&lt;String&gt;(new CallableDemo(&quot;Thread-A&quot;, 5000));</div><div class="line">		Thread tA = new Thread(futureA);</div><div class="line">		tA.start();</div><div class="line">		System.out.println(&quot;Thread is Done: &quot; + futureA.isDone());</div><div class="line">		System.out.println(futureA.get());</div><div class="line">		System.out.println(&quot;Thread is Done: &quot; + futureA.isDone());</div><div class="line">		FutureTask&lt;String&gt; futureB = new FutureTask&lt;String&gt;(new CallableDemo(&quot;Thread-B&quot;, 400));</div><div class="line">		Thread tB = new Thread(futureB);</div><div class="line">		tB.start();</div><div class="line">		long end = System.currentTimeMillis();</div><div class="line">		System.out.println(&quot;During time: &quot; + (end - start));</div><div class="line"></div><div class="line">	&#125;</div><div class="line">&#125;</div></pre></td></tr></table></figure>
<p>这里也是实现了两个线程tA和tB,和上面Thread和Runnable的不同之处在于，这里使用futureA和futureB来获取两个线程的执行状态。futureA.isDone()。这两需要着重说的是futureA.get().这个方法的意思是：主线程等待tA执行完成。这个方法是会阻塞主线程的运行。下面是测试结果:<br><img src="http://img.blog.csdn.net/20170216140031635?watermark/2/text/aHR0cDovL2Jsb2cuY3Nkbi5uZXQvcWlzaWJhamll/font/5a6L5L2T/fontsize/400/fill/I0JBQkFCMA==/dissolve/70/gravity/SouthEast" alt="这里写图片描述"><br>可以看到被标记的就是返回值，这是通过get()方法得到的，主线程会成tA执行完成之后，才会继续向下执行，而tB没有调用futureB.get(),所以tB没有阻塞主线程，和主线程是并发的。可以看到<strong>‘During time: 5003’</strong>在tB没有执行完成的时候已经被执行。</p>
<p>#总结<br>这篇主要介绍了自己实现多线程的三种方式:</p>
<ol>
<li>extends Thread,重写run()方法</li>
<li>implements Runnable， 实现run()方法</li>
<li>implements Callable&lt;&gt;，实现call()方法，可以获取线程的执行状态信息，isDone(),isCancelled()</li>
</ol>
<p>下一篇我们会介绍，线程并发时候的共享资源问题。</p>
]]></content>
      
        <categories>
            
            <category> Java </category>
            
        </categories>
        
        
        <tags>
            
            <tag> Java </tag>
            
            <tag> 线程池 </tag>
            
        </tags>
        
    </entry>
    
    <entry>
      <title><![CDATA[Hexo用法]]></title>
      <url>/2017/05/22/hello-world/</url>
      <content type="html"><![CDATA[<p>Welcome to <a href="https://hexo.io/" target="_blank" rel="external">Hexo</a>! This is your very first post. Check <a href="https://hexo.io/docs/" target="_blank" rel="external">documentation</a> for more info. If you get any problems when using Hexo, you can find the answer in <a href="https://hexo.io/docs/troubleshooting.html" target="_blank" rel="external">troubleshooting</a> or you can ask me on <a href="https://github.com/hexojs/hexo/issues" target="_blank" rel="external">GitHub</a>.</p>
<h2 id="Quick-Start"><a href="#Quick-Start" class="headerlink" title="Quick Start"></a>Quick Start</h2><h3 id="Create-a-new-post"><a href="#Create-a-new-post" class="headerlink" title="Create a new post"></a>Create a new post</h3><figure class="highlight bash"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line">$ hexo new <span class="string">"My New Post"</span></div></pre></td></tr></table></figure>
<p>More info: <a href="https://hexo.io/docs/writing.html" target="_blank" rel="external">Writing</a></p>
<h3 id="Run-server"><a href="#Run-server" class="headerlink" title="Run server"></a>Run server</h3><figure class="highlight bash"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line">$ hexo server</div></pre></td></tr></table></figure>
<p>More info: <a href="https://hexo.io/docs/server.html" target="_blank" rel="external">Server</a></p>
<h3 id="Generate-static-files"><a href="#Generate-static-files" class="headerlink" title="Generate static files"></a>Generate static files</h3><figure class="highlight bash"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line">$ hexo generate</div></pre></td></tr></table></figure>
<p>More info: <a href="https://hexo.io/docs/generating.html" target="_blank" rel="external">Generating</a></p>
<h3 id="Deploy-to-remote-sites"><a href="#Deploy-to-remote-sites" class="headerlink" title="Deploy to remote sites"></a>Deploy to remote sites</h3><figure class="highlight bash"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line">$ hexo deploy</div></pre></td></tr></table></figure>
<p>More info: <a href="https://hexo.io/docs/deployment.html" target="_blank" rel="external">Deployment</a></p>
]]></content>
      
        <categories>
            
            <category> 博客搭建 </category>
            
        </categories>
        
        
        <tags>
            
            <tag> Hexo，博客 </tag>
            
        </tags>
        
    </entry>
    
    <entry>
      <title><![CDATA[心情小记]]></title>
      <url>/2017/05/22/%E5%BF%83%E6%83%85%E5%B0%8F%E8%AE%B0/</url>
      <content type="html"><![CDATA[<h3 id="心情小计"><a href="#心情小计" class="headerlink" title="心情小计"></a>心情小计</h3><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line">今天读了得到之后，看到了一句话，要成为别人最需要的人。因为需求决定价格。</div></pre></td></tr></table></figure>]]></content>
      
        <categories>
            
            <category> 日常小记 </category>
            
        </categories>
        
        
        <tags>
            
            <tag> 心情，感悟 </tag>
            
        </tags>
        
    </entry>
    
  
  
</search>
